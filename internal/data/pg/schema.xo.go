// Package pg contains generated code for schema 'public'.
package pg

// Code generated by xo. DO NOT EDIT.

import (
	"context"
	"database/sql"

	"gitlab.com/distributed_lab/kit/pgdb"
	"gitlab.com/distributed_lab/logan/v3/errors"

	"github.com/google/uuid"
	"github.com/rarimo/rarime-orgs-svc/internal/data"
)

// Storage is the helper struct for database operations
type Storage struct {
	db *pgdb.DB
}

// New - returns new instance of storage
func New(db *pgdb.DB) *Storage {
	return &Storage{
		db,
	}
}

// DB - returns db used by Storage
func (s *Storage) DB() *pgdb.DB {
	return s.db
}

// Clone - returns new storage with clone of db
func (s *Storage) Clone() data.Storage {
	return New(s.db.Clone())
}

// Transaction begins a transaction on repo.
func (s *Storage) Transaction(tx func() error) error {
	return s.db.Transaction(tx)
} // EmailInvitationQ represents helper struct to access row of 'email_invitations'.
type EmailInvitationQ struct {
	db *pgdb.DB
}

// NewEmailInvitationQ  - creates new instance
func NewEmailInvitationQ(db *pgdb.DB) EmailInvitationQ {
	return EmailInvitationQ{
		db,
	}
}

// EmailInvitationQ  - creates new instance of EmailInvitationQ
func (s Storage) EmailInvitationQ() data.EmailInvitationQ {
	return NewEmailInvitationQ(s.DB())
}

var colsEmailInvitation = `id, req_id, org_id, group_id, email, otp, created_at`

// InsertCtx inserts a EmailInvitation to the database.
func (q EmailInvitationQ) InsertCtx(ctx context.Context, ei *data.EmailInvitation) error {
	// sql insert query, primary key must be provided
	sqlstr := `INSERT INTO public.email_invitations (` +
		`id, req_id, org_id, group_id, email, otp, created_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`)`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, ei.ID, ei.ReqID, ei.OrgID, ei.GroupID, ei.Email, ei.Otp, ei.CreatedAt)
	return errors.Wrap(err, "failed to execute insert query")
}

// Insert insert a EmailInvitation to the database.
func (q EmailInvitationQ) Insert(ei *data.EmailInvitation) error {
	return q.InsertCtx(context.Background(), ei)
}

// UpdateCtx updates a EmailInvitation in the database.
func (q EmailInvitationQ) UpdateCtx(ctx context.Context, ei *data.EmailInvitation) error {
	// update with composite primary key
	sqlstr := `UPDATE public.email_invitations SET ` +
		`req_id = $1, org_id = $2, group_id = $3, email = $4, otp = $5 ` +
		`WHERE id = $6`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, ei.ReqID, ei.OrgID, ei.GroupID, ei.Email, ei.Otp, ei.ID)
	return errors.Wrap(err, "failed to execute update")
}

// Update updates a EmailInvitation in the database.
func (q EmailInvitationQ) Update(ei *data.EmailInvitation) error {
	return q.UpdateCtx(context.Background(), ei)
}

// UpsertCtx performs an upsert for EmailInvitation.
func (q EmailInvitationQ) UpsertCtx(ctx context.Context, ei *data.EmailInvitation) error {
	// upsert
	sqlstr := `INSERT INTO public.email_invitations (` +
		`id, req_id, org_id, group_id, email, otp, created_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`req_id = EXCLUDED.req_id, org_id = EXCLUDED.org_id, group_id = EXCLUDED.group_id, email = EXCLUDED.email, otp = EXCLUDED.otp `
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, ei.ID, ei.ReqID, ei.OrgID, ei.GroupID, ei.Email, ei.Otp, ei.CreatedAt); err != nil {
		return errors.Wrap(err, "failed to execute upsert stmt")
	}
	return nil
}

// Upsert performs an upsert for EmailInvitation.
func (q EmailInvitationQ) Upsert(ei *data.EmailInvitation) error {
	return q.UpsertCtx(context.Background(), ei)
}

// DeleteCtx deletes the EmailInvitation from the database.
func (q EmailInvitationQ) DeleteCtx(ctx context.Context, ei *data.EmailInvitation) error {
	// delete with single primary key
	sqlstr := `DELETE FROM public.email_invitations ` +
		`WHERE id = $1`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, ei.ID); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// Delete deletes the EmailInvitation from the database.
func (q EmailInvitationQ) Delete(ei *data.EmailInvitation) error {
	return q.DeleteCtx(context.Background(), ei)
} // GorpMigrationQ represents helper struct to access row of 'gorp_migrations'.
type GorpMigrationQ struct {
	db *pgdb.DB
}

// NewGorpMigrationQ  - creates new instance
func NewGorpMigrationQ(db *pgdb.DB) GorpMigrationQ {
	return GorpMigrationQ{
		db,
	}
}

// GorpMigrationQ  - creates new instance of GorpMigrationQ
func (s Storage) GorpMigrationQ() data.GorpMigrationQ {
	return NewGorpMigrationQ(s.DB())
}

var colsGorpMigration = `id, applied_at`

// InsertCtx inserts a GorpMigration to the database.
func (q GorpMigrationQ) InsertCtx(ctx context.Context, gm *data.GorpMigration) error {
	// sql insert query, primary key must be provided
	sqlstr := `INSERT INTO public.gorp_migrations (` +
		`id, applied_at` +
		`) VALUES (` +
		`$1, $2` +
		`)`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, gm.ID, gm.AppliedAt)
	return errors.Wrap(err, "failed to execute insert query")
}

// Insert insert a GorpMigration to the database.
func (q GorpMigrationQ) Insert(gm *data.GorpMigration) error {
	return q.InsertCtx(context.Background(), gm)
}

// UpdateCtx updates a GorpMigration in the database.
func (q GorpMigrationQ) UpdateCtx(ctx context.Context, gm *data.GorpMigration) error {
	// update with composite primary key
	sqlstr := `UPDATE public.gorp_migrations SET ` +
		`applied_at = $1 ` +
		`WHERE id = $2`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, gm.AppliedAt, gm.ID)
	return errors.Wrap(err, "failed to execute update")
}

// Update updates a GorpMigration in the database.
func (q GorpMigrationQ) Update(gm *data.GorpMigration) error {
	return q.UpdateCtx(context.Background(), gm)
}

// UpsertCtx performs an upsert for GorpMigration.
func (q GorpMigrationQ) UpsertCtx(ctx context.Context, gm *data.GorpMigration) error {
	// upsert
	sqlstr := `INSERT INTO public.gorp_migrations (` +
		`id, applied_at` +
		`) VALUES (` +
		`$1, $2` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`applied_at = EXCLUDED.applied_at `
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, gm.ID, gm.AppliedAt); err != nil {
		return errors.Wrap(err, "failed to execute upsert stmt")
	}
	return nil
}

// Upsert performs an upsert for GorpMigration.
func (q GorpMigrationQ) Upsert(gm *data.GorpMigration) error {
	return q.UpsertCtx(context.Background(), gm)
}

// DeleteCtx deletes the GorpMigration from the database.
func (q GorpMigrationQ) DeleteCtx(ctx context.Context, gm *data.GorpMigration) error {
	// delete with single primary key
	sqlstr := `DELETE FROM public.gorp_migrations ` +
		`WHERE id = $1`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, gm.ID); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// Delete deletes the GorpMigration from the database.
func (q GorpMigrationQ) Delete(gm *data.GorpMigration) error {
	return q.DeleteCtx(context.Background(), gm)
} // GroupQ represents helper struct to access row of 'groups'.
type GroupQ struct {
	db *pgdb.DB
}

// NewGroupQ  - creates new instance
func NewGroupQ(db *pgdb.DB) GroupQ {
	return GroupQ{
		db,
	}
}

// GroupQ  - creates new instance of GroupQ
func (s Storage) GroupQ() data.GroupQ {
	return NewGroupQ(s.DB())
}

var colsGroup = `id, org_id, metadata, rules, created_at`

// InsertCtx inserts a Group to the database.
func (q GroupQ) InsertCtx(ctx context.Context, g *data.Group) error {
	// sql insert query, primary key must be provided
	sqlstr := `INSERT INTO public.groups (` +
		`id, org_id, metadata, rules, created_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`)`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, g.ID, g.OrgID, g.Metadata, g.Rules, g.CreatedAt)
	return errors.Wrap(err, "failed to execute insert query")
}

// Insert insert a Group to the database.
func (q GroupQ) Insert(g *data.Group) error {
	return q.InsertCtx(context.Background(), g)
}

// UpdateCtx updates a Group in the database.
func (q GroupQ) UpdateCtx(ctx context.Context, g *data.Group) error {
	// update with composite primary key
	sqlstr := `UPDATE public.groups SET ` +
		`org_id = $1, metadata = $2, rules = $3 ` +
		`WHERE id = $4`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, g.OrgID, g.Metadata, g.Rules, g.ID)
	return errors.Wrap(err, "failed to execute update")
}

// Update updates a Group in the database.
func (q GroupQ) Update(g *data.Group) error {
	return q.UpdateCtx(context.Background(), g)
}

// UpsertCtx performs an upsert for Group.
func (q GroupQ) UpsertCtx(ctx context.Context, g *data.Group) error {
	// upsert
	sqlstr := `INSERT INTO public.groups (` +
		`id, org_id, metadata, rules, created_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`org_id = EXCLUDED.org_id, metadata = EXCLUDED.metadata, rules = EXCLUDED.rules `
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, g.ID, g.OrgID, g.Metadata, g.Rules, g.CreatedAt); err != nil {
		return errors.Wrap(err, "failed to execute upsert stmt")
	}
	return nil
}

// Upsert performs an upsert for Group.
func (q GroupQ) Upsert(g *data.Group) error {
	return q.UpsertCtx(context.Background(), g)
}

// DeleteCtx deletes the Group from the database.
func (q GroupQ) DeleteCtx(ctx context.Context, g *data.Group) error {
	// delete with single primary key
	sqlstr := `DELETE FROM public.groups ` +
		`WHERE id = $1`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, g.ID); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// Delete deletes the Group from the database.
func (q GroupQ) Delete(g *data.Group) error {
	return q.DeleteCtx(context.Background(), g)
} // GroupUserQ represents helper struct to access row of 'group_users'.
type GroupUserQ struct {
	db *pgdb.DB
}

// NewGroupUserQ  - creates new instance
func NewGroupUserQ(db *pgdb.DB) GroupUserQ {
	return GroupUserQ{
		db,
	}
}

// GroupUserQ  - creates new instance of GroupUserQ
func (s Storage) GroupUserQ() data.GroupUserQ {
	return NewGroupUserQ(s.DB())
}

var colsGroupUser = `id, group_id, user_id, role, created_at, updated_at`

// InsertCtx inserts a GroupUser to the database.
func (q GroupUserQ) InsertCtx(ctx context.Context, gu *data.GroupUser) error {
	// sql insert query, primary key must be provided
	sqlstr := `INSERT INTO public.group_users (` +
		`id, group_id, user_id, role, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`)`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, gu.ID, gu.GroupID, gu.UserID, gu.Role, gu.CreatedAt, gu.UpdatedAt)
	return errors.Wrap(err, "failed to execute insert query")
}

// Insert insert a GroupUser to the database.
func (q GroupUserQ) Insert(gu *data.GroupUser) error {
	return q.InsertCtx(context.Background(), gu)
}

// UpdateCtx updates a GroupUser in the database.
func (q GroupUserQ) UpdateCtx(ctx context.Context, gu *data.GroupUser) error {
	// update with composite primary key
	sqlstr := `UPDATE public.group_users SET ` +
		`group_id = $1, user_id = $2, role = $3, updated_at = $4 ` +
		`WHERE id = $5`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, gu.GroupID, gu.UserID, gu.Role, gu.UpdatedAt, gu.ID)
	return errors.Wrap(err, "failed to execute update")
}

// Update updates a GroupUser in the database.
func (q GroupUserQ) Update(gu *data.GroupUser) error {
	return q.UpdateCtx(context.Background(), gu)
}

// UpsertCtx performs an upsert for GroupUser.
func (q GroupUserQ) UpsertCtx(ctx context.Context, gu *data.GroupUser) error {
	// upsert
	sqlstr := `INSERT INTO public.group_users (` +
		`id, group_id, user_id, role, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`group_id = EXCLUDED.group_id, user_id = EXCLUDED.user_id, role = EXCLUDED.role, updated_at = EXCLUDED.updated_at `
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, gu.ID, gu.GroupID, gu.UserID, gu.Role, gu.CreatedAt, gu.UpdatedAt); err != nil {
		return errors.Wrap(err, "failed to execute upsert stmt")
	}
	return nil
}

// Upsert performs an upsert for GroupUser.
func (q GroupUserQ) Upsert(gu *data.GroupUser) error {
	return q.UpsertCtx(context.Background(), gu)
}

// DeleteCtx deletes the GroupUser from the database.
func (q GroupUserQ) DeleteCtx(ctx context.Context, gu *data.GroupUser) error {
	// delete with single primary key
	sqlstr := `DELETE FROM public.group_users ` +
		`WHERE id = $1`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, gu.ID); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// Delete deletes the GroupUser from the database.
func (q GroupUserQ) Delete(gu *data.GroupUser) error {
	return q.DeleteCtx(context.Background(), gu)
} // OrganizationQ represents helper struct to access row of 'organizations'.
type OrganizationQ struct {
	db *pgdb.DB
}

// NewOrganizationQ  - creates new instance
func NewOrganizationQ(db *pgdb.DB) OrganizationQ {
	return OrganizationQ{
		db,
	}
}

// OrganizationQ  - creates new instance of OrganizationQ
func (s Storage) OrganizationQ() data.OrganizationQ {
	return NewOrganizationQ(s.DB())
}

var colsOrganization = `id, did, owner, domain, metadata, status, verification_code, issued_claims_count, members_count, created_at, updated_at`

// InsertCtx inserts a Organization to the database.
func (q OrganizationQ) InsertCtx(ctx context.Context, o *data.Organization) error {
	// sql insert query, primary key must be provided
	sqlstr := `INSERT INTO public.organizations (` +
		`id, did, owner, domain, metadata, status, verification_code, issued_claims_count, members_count, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11` +
		`)`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, o.ID, o.Did, o.Owner, o.Domain, o.Metadata, o.Status, o.VerificationCode, o.IssuedClaimsCount, o.MembersCount, o.CreatedAt, o.UpdatedAt)
	return errors.Wrap(err, "failed to execute insert query")
}

// Insert insert a Organization to the database.
func (q OrganizationQ) Insert(o *data.Organization) error {
	return q.InsertCtx(context.Background(), o)
}

// UpdateCtx updates a Organization in the database.
func (q OrganizationQ) UpdateCtx(ctx context.Context, o *data.Organization) error {
	// update with composite primary key
	sqlstr := `UPDATE public.organizations SET ` +
		`did = $1, owner = $2, domain = $3, metadata = $4, status = $5, verification_code = $6, issued_claims_count = $7, members_count = $8, updated_at = $9 ` +
		`WHERE id = $10`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, o.Did, o.Owner, o.Domain, o.Metadata, o.Status, o.VerificationCode, o.IssuedClaimsCount, o.MembersCount, o.UpdatedAt, o.ID)
	return errors.Wrap(err, "failed to execute update")
}

// Update updates a Organization in the database.
func (q OrganizationQ) Update(o *data.Organization) error {
	return q.UpdateCtx(context.Background(), o)
}

// UpsertCtx performs an upsert for Organization.
func (q OrganizationQ) UpsertCtx(ctx context.Context, o *data.Organization) error {
	// upsert
	sqlstr := `INSERT INTO public.organizations (` +
		`id, did, owner, domain, metadata, status, verification_code, issued_claims_count, members_count, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`did = EXCLUDED.did, owner = EXCLUDED.owner, domain = EXCLUDED.domain, metadata = EXCLUDED.metadata, status = EXCLUDED.status, verification_code = EXCLUDED.verification_code, issued_claims_count = EXCLUDED.issued_claims_count, members_count = EXCLUDED.members_count, updated_at = EXCLUDED.updated_at `
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, o.ID, o.Did, o.Owner, o.Domain, o.Metadata, o.Status, o.VerificationCode, o.IssuedClaimsCount, o.MembersCount, o.CreatedAt, o.UpdatedAt); err != nil {
		return errors.Wrap(err, "failed to execute upsert stmt")
	}
	return nil
}

// Upsert performs an upsert for Organization.
func (q OrganizationQ) Upsert(o *data.Organization) error {
	return q.UpsertCtx(context.Background(), o)
}

// DeleteCtx deletes the Organization from the database.
func (q OrganizationQ) DeleteCtx(ctx context.Context, o *data.Organization) error {
	// delete with single primary key
	sqlstr := `DELETE FROM public.organizations ` +
		`WHERE id = $1`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, o.ID); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// Delete deletes the Organization from the database.
func (q OrganizationQ) Delete(o *data.Organization) error {
	return q.DeleteCtx(context.Background(), o)
} // RequestQ represents helper struct to access row of 'requests'.
type RequestQ struct {
	db *pgdb.DB
}

// NewRequestQ  - creates new instance
func NewRequestQ(db *pgdb.DB) RequestQ {
	return RequestQ{
		db,
	}
}

// RequestQ  - creates new instance of RequestQ
func (s Storage) RequestQ() data.RequestQ {
	return NewRequestQ(s.DB())
}

var colsRequest = `id, org_id, group_id, user_did, metadata, status, created_at, updated_at`

// InsertCtx inserts a Request to the database.
func (q RequestQ) InsertCtx(ctx context.Context, r *data.Request) error {
	// sql insert query, primary key must be provided
	sqlstr := `INSERT INTO public.requests (` +
		`id, org_id, group_id, user_did, metadata, status, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8` +
		`)`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, r.ID, r.OrgID, r.GroupID, r.UserDid, r.Metadata, r.Status, r.CreatedAt, r.UpdatedAt)
	return errors.Wrap(err, "failed to execute insert query")
}

// Insert insert a Request to the database.
func (q RequestQ) Insert(r *data.Request) error {
	return q.InsertCtx(context.Background(), r)
}

// UpdateCtx updates a Request in the database.
func (q RequestQ) UpdateCtx(ctx context.Context, r *data.Request) error {
	// update with composite primary key
	sqlstr := `UPDATE public.requests SET ` +
		`org_id = $1, group_id = $2, user_did = $3, metadata = $4, status = $5, updated_at = $6 ` +
		`WHERE id = $7`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, r.OrgID, r.GroupID, r.UserDid, r.Metadata, r.Status, r.UpdatedAt, r.ID)
	return errors.Wrap(err, "failed to execute update")
}

// Update updates a Request in the database.
func (q RequestQ) Update(r *data.Request) error {
	return q.UpdateCtx(context.Background(), r)
}

// UpsertCtx performs an upsert for Request.
func (q RequestQ) UpsertCtx(ctx context.Context, r *data.Request) error {
	// upsert
	sqlstr := `INSERT INTO public.requests (` +
		`id, org_id, group_id, user_did, metadata, status, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6, $7, $8` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`org_id = EXCLUDED.org_id, group_id = EXCLUDED.group_id, user_did = EXCLUDED.user_did, metadata = EXCLUDED.metadata, status = EXCLUDED.status, updated_at = EXCLUDED.updated_at `
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, r.ID, r.OrgID, r.GroupID, r.UserDid, r.Metadata, r.Status, r.CreatedAt, r.UpdatedAt); err != nil {
		return errors.Wrap(err, "failed to execute upsert stmt")
	}
	return nil
}

// Upsert performs an upsert for Request.
func (q RequestQ) Upsert(r *data.Request) error {
	return q.UpsertCtx(context.Background(), r)
}

// DeleteCtx deletes the Request from the database.
func (q RequestQ) DeleteCtx(ctx context.Context, r *data.Request) error {
	// delete with single primary key
	sqlstr := `DELETE FROM public.requests ` +
		`WHERE id = $1`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, r.ID); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// Delete deletes the Request from the database.
func (q RequestQ) Delete(r *data.Request) error {
	return q.DeleteCtx(context.Background(), r)
} // UserQ represents helper struct to access row of 'users'.
type UserQ struct {
	db *pgdb.DB
}

// NewUserQ  - creates new instance
func NewUserQ(db *pgdb.DB) UserQ {
	return UserQ{
		db,
	}
}

// UserQ  - creates new instance of UserQ
func (s Storage) UserQ() data.UserQ {
	return NewUserQ(s.DB())
}

var colsUser = `id, did, org_id, role, created_at, updated_at`

// InsertCtx inserts a User to the database.
func (q UserQ) InsertCtx(ctx context.Context, u *data.User) error {
	// sql insert query, primary key must be provided
	sqlstr := `INSERT INTO public.users (` +
		`id, did, org_id, role, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`)`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, u.ID, u.Did, u.OrgID, u.Role, u.CreatedAt, u.UpdatedAt)
	return errors.Wrap(err, "failed to execute insert query")
}

// Insert insert a User to the database.
func (q UserQ) Insert(u *data.User) error {
	return q.InsertCtx(context.Background(), u)
}

// UpdateCtx updates a User in the database.
func (q UserQ) UpdateCtx(ctx context.Context, u *data.User) error {
	// update with composite primary key
	sqlstr := `UPDATE public.users SET ` +
		`did = $1, org_id = $2, role = $3, updated_at = $4 ` +
		`WHERE id = $5`
	// run
	err := q.db.ExecRawContext(ctx, sqlstr, u.Did, u.OrgID, u.Role, u.UpdatedAt, u.ID)
	return errors.Wrap(err, "failed to execute update")
}

// Update updates a User in the database.
func (q UserQ) Update(u *data.User) error {
	return q.UpdateCtx(context.Background(), u)
}

// UpsertCtx performs an upsert for User.
func (q UserQ) UpsertCtx(ctx context.Context, u *data.User) error {
	// upsert
	sqlstr := `INSERT INTO public.users (` +
		`id, did, org_id, role, created_at, updated_at` +
		`) VALUES (` +
		`$1, $2, $3, $4, $5, $6` +
		`)` +
		` ON CONFLICT (id) DO ` +
		`UPDATE SET ` +
		`did = EXCLUDED.did, org_id = EXCLUDED.org_id, role = EXCLUDED.role, updated_at = EXCLUDED.updated_at `
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, u.ID, u.Did, u.OrgID, u.Role, u.CreatedAt, u.UpdatedAt); err != nil {
		return errors.Wrap(err, "failed to execute upsert stmt")
	}
	return nil
}

// Upsert performs an upsert for User.
func (q UserQ) Upsert(u *data.User) error {
	return q.UpsertCtx(context.Background(), u)
}

// DeleteCtx deletes the User from the database.
func (q UserQ) DeleteCtx(ctx context.Context, u *data.User) error {
	// delete with single primary key
	sqlstr := `DELETE FROM public.users ` +
		`WHERE id = $1`
	// run
	if err := q.db.ExecRawContext(ctx, sqlstr, u.ID); err != nil {
		return errors.Wrap(err, "failed to exec delete stmt")
	}
	return nil
}

// Delete deletes the User from the database.
func (q UserQ) Delete(u *data.User) error {
	return q.DeleteCtx(context.Background(), u)
}

// EmailInvitationsByGroupIDCtx retrieves a row from 'public.email_invitations' as a EmailInvitation.
//
// Generated from index 'email_invitations_group_index'.
func (q EmailInvitationQ) EmailInvitationsByGroupIDCtx(ctx context.Context, groupID uuid.UUID, isForUpdate bool) ([]data.EmailInvitation, error) {
	// query
	sqlstr := `SELECT ` +
		`id, req_id, org_id, group_id, email, otp, created_at ` +
		`FROM public.email_invitations ` +
		`WHERE group_id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res []data.EmailInvitation
	err := q.db.SelectRawContext(ctx, &res, sqlstr, groupID)
	if err != nil {
		return nil, errors.Wrap(err, "failed to exec select")
	}

	return res, nil
}

// EmailInvitationsByGroupID retrieves a row from 'public.email_invitations' as a EmailInvitation.
//
// Generated from index 'email_invitations_group_index'.
func (q EmailInvitationQ) EmailInvitationsByGroupID(groupID uuid.UUID, isForUpdate bool) ([]data.EmailInvitation, error) {
	return q.EmailInvitationsByGroupIDCtx(context.Background(), groupID, isForUpdate)
}

// EmailInvitationsByOrgIDCtx retrieves a row from 'public.email_invitations' as a EmailInvitation.
//
// Generated from index 'email_invitations_organization_index'.
func (q EmailInvitationQ) EmailInvitationsByOrgIDCtx(ctx context.Context, orgID uuid.UUID, isForUpdate bool) ([]data.EmailInvitation, error) {
	// query
	sqlstr := `SELECT ` +
		`id, req_id, org_id, group_id, email, otp, created_at ` +
		`FROM public.email_invitations ` +
		`WHERE org_id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res []data.EmailInvitation
	err := q.db.SelectRawContext(ctx, &res, sqlstr, orgID)
	if err != nil {
		return nil, errors.Wrap(err, "failed to exec select")
	}

	return res, nil
}

// EmailInvitationsByOrgID retrieves a row from 'public.email_invitations' as a EmailInvitation.
//
// Generated from index 'email_invitations_organization_index'.
func (q EmailInvitationQ) EmailInvitationsByOrgID(orgID uuid.UUID, isForUpdate bool) ([]data.EmailInvitation, error) {
	return q.EmailInvitationsByOrgIDCtx(context.Background(), orgID, isForUpdate)
}

// EmailInvitationByIDCtx retrieves a row from 'public.email_invitations' as a EmailInvitation.
//
// Generated from index 'email_invitations_pkey'.
func (q EmailInvitationQ) EmailInvitationByIDCtx(ctx context.Context, id uuid.UUID, isForUpdate bool) (*data.EmailInvitation, error) {
	// query
	sqlstr := `SELECT ` +
		`id, req_id, org_id, group_id, email, otp, created_at ` +
		`FROM public.email_invitations ` +
		`WHERE id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.EmailInvitation
	err := q.db.GetRawContext(ctx, &res, sqlstr, id)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// EmailInvitationByID retrieves a row from 'public.email_invitations' as a EmailInvitation.
//
// Generated from index 'email_invitations_pkey'.
func (q EmailInvitationQ) EmailInvitationByID(id uuid.UUID, isForUpdate bool) (*data.EmailInvitation, error) {
	return q.EmailInvitationByIDCtx(context.Background(), id, isForUpdate)
}

// EmailInvitationsByReqIDCtx retrieves a row from 'public.email_invitations' as a EmailInvitation.
//
// Generated from index 'email_invitations_request_index'.
func (q EmailInvitationQ) EmailInvitationsByReqIDCtx(ctx context.Context, reqID uuid.UUID, isForUpdate bool) ([]data.EmailInvitation, error) {
	// query
	sqlstr := `SELECT ` +
		`id, req_id, org_id, group_id, email, otp, created_at ` +
		`FROM public.email_invitations ` +
		`WHERE req_id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res []data.EmailInvitation
	err := q.db.SelectRawContext(ctx, &res, sqlstr, reqID)
	if err != nil {
		return nil, errors.Wrap(err, "failed to exec select")
	}

	return res, nil
}

// EmailInvitationsByReqID retrieves a row from 'public.email_invitations' as a EmailInvitation.
//
// Generated from index 'email_invitations_request_index'.
func (q EmailInvitationQ) EmailInvitationsByReqID(reqID uuid.UUID, isForUpdate bool) ([]data.EmailInvitation, error) {
	return q.EmailInvitationsByReqIDCtx(context.Background(), reqID, isForUpdate)
}

// GorpMigrationByIDCtx retrieves a row from 'public.gorp_migrations' as a GorpMigration.
//
// Generated from index 'gorp_migrations_pkey'.
func (q GorpMigrationQ) GorpMigrationByIDCtx(ctx context.Context, id string, isForUpdate bool) (*data.GorpMigration, error) {
	// query
	sqlstr := `SELECT ` +
		`id, applied_at ` +
		`FROM public.gorp_migrations ` +
		`WHERE id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.GorpMigration
	err := q.db.GetRawContext(ctx, &res, sqlstr, id)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// GorpMigrationByID retrieves a row from 'public.gorp_migrations' as a GorpMigration.
//
// Generated from index 'gorp_migrations_pkey'.
func (q GorpMigrationQ) GorpMigrationByID(id string, isForUpdate bool) (*data.GorpMigration, error) {
	return q.GorpMigrationByIDCtx(context.Background(), id, isForUpdate)
}

// GroupsByOrgIDCtx retrieves a row from 'public.groups' as a Group.
//
// Generated from index 'groups_organization_index'.
func (q GroupQ) GroupsByOrgIDCtx(ctx context.Context, orgID uuid.UUID, isForUpdate bool) ([]data.Group, error) {
	// query
	sqlstr := `SELECT ` +
		`id, org_id, metadata, rules, created_at ` +
		`FROM public.groups ` +
		`WHERE org_id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res []data.Group
	err := q.db.SelectRawContext(ctx, &res, sqlstr, orgID)
	if err != nil {
		return nil, errors.Wrap(err, "failed to exec select")
	}

	return res, nil
}

// GroupsByOrgID retrieves a row from 'public.groups' as a Group.
//
// Generated from index 'groups_organization_index'.
func (q GroupQ) GroupsByOrgID(orgID uuid.UUID, isForUpdate bool) ([]data.Group, error) {
	return q.GroupsByOrgIDCtx(context.Background(), orgID, isForUpdate)
}

// GroupByIDCtx retrieves a row from 'public.groups' as a Group.
//
// Generated from index 'groups_pkey'.
func (q GroupQ) GroupByIDCtx(ctx context.Context, id uuid.UUID, isForUpdate bool) (*data.Group, error) {
	// query
	sqlstr := `SELECT ` +
		`id, org_id, metadata, rules, created_at ` +
		`FROM public.groups ` +
		`WHERE id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.Group
	err := q.db.GetRawContext(ctx, &res, sqlstr, id)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// GroupByID retrieves a row from 'public.groups' as a Group.
//
// Generated from index 'groups_pkey'.
func (q GroupQ) GroupByID(id uuid.UUID, isForUpdate bool) (*data.Group, error) {
	return q.GroupByIDCtx(context.Background(), id, isForUpdate)
}

// GroupUsersByGroupIDCtx retrieves a row from 'public.group_users' as a GroupUser.
//
// Generated from index 'group_users_group_index'.
func (q GroupUserQ) GroupUsersByGroupIDCtx(ctx context.Context, groupID uuid.UUID, isForUpdate bool) ([]data.GroupUser, error) {
	// query
	sqlstr := `SELECT ` +
		`id, group_id, user_id, role, created_at, updated_at ` +
		`FROM public.group_users ` +
		`WHERE group_id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res []data.GroupUser
	err := q.db.SelectRawContext(ctx, &res, sqlstr, groupID)
	if err != nil {
		return nil, errors.Wrap(err, "failed to exec select")
	}

	return res, nil
}

// GroupUsersByGroupID retrieves a row from 'public.group_users' as a GroupUser.
//
// Generated from index 'group_users_group_index'.
func (q GroupUserQ) GroupUsersByGroupID(groupID uuid.UUID, isForUpdate bool) ([]data.GroupUser, error) {
	return q.GroupUsersByGroupIDCtx(context.Background(), groupID, isForUpdate)
}

// GroupUserByIDCtx retrieves a row from 'public.group_users' as a GroupUser.
//
// Generated from index 'group_users_pkey'.
func (q GroupUserQ) GroupUserByIDCtx(ctx context.Context, id uuid.UUID, isForUpdate bool) (*data.GroupUser, error) {
	// query
	sqlstr := `SELECT ` +
		`id, group_id, user_id, role, created_at, updated_at ` +
		`FROM public.group_users ` +
		`WHERE id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.GroupUser
	err := q.db.GetRawContext(ctx, &res, sqlstr, id)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// GroupUserByID retrieves a row from 'public.group_users' as a GroupUser.
//
// Generated from index 'group_users_pkey'.
func (q GroupUserQ) GroupUserByID(id uuid.UUID, isForUpdate bool) (*data.GroupUser, error) {
	return q.GroupUserByIDCtx(context.Background(), id, isForUpdate)
}

// GroupUsersByUserIDCtx retrieves a row from 'public.group_users' as a GroupUser.
//
// Generated from index 'group_users_user_index'.
func (q GroupUserQ) GroupUsersByUserIDCtx(ctx context.Context, userID uuid.UUID, isForUpdate bool) ([]data.GroupUser, error) {
	// query
	sqlstr := `SELECT ` +
		`id, group_id, user_id, role, created_at, updated_at ` +
		`FROM public.group_users ` +
		`WHERE user_id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res []data.GroupUser
	err := q.db.SelectRawContext(ctx, &res, sqlstr, userID)
	if err != nil {
		return nil, errors.Wrap(err, "failed to exec select")
	}

	return res, nil
}

// GroupUsersByUserID retrieves a row from 'public.group_users' as a GroupUser.
//
// Generated from index 'group_users_user_index'.
func (q GroupUserQ) GroupUsersByUserID(userID uuid.UUID, isForUpdate bool) ([]data.GroupUser, error) {
	return q.GroupUsersByUserIDCtx(context.Background(), userID, isForUpdate)
}

// OrganizationsByOwnerCtx retrieves a row from 'public.organizations' as a Organization.
//
// Generated from index 'organizations_owner_index'.
func (q OrganizationQ) OrganizationsByOwnerCtx(ctx context.Context, owner uuid.UUID, isForUpdate bool) ([]data.Organization, error) {
	// query
	sqlstr := `SELECT ` +
		`id, did, owner, domain, metadata, status, verification_code, issued_claims_count, members_count, created_at, updated_at ` +
		`FROM public.organizations ` +
		`WHERE owner = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res []data.Organization
	err := q.db.SelectRawContext(ctx, &res, sqlstr, owner)
	if err != nil {
		return nil, errors.Wrap(err, "failed to exec select")
	}

	return res, nil
}

// OrganizationsByOwner retrieves a row from 'public.organizations' as a Organization.
//
// Generated from index 'organizations_owner_index'.
func (q OrganizationQ) OrganizationsByOwner(owner uuid.UUID, isForUpdate bool) ([]data.Organization, error) {
	return q.OrganizationsByOwnerCtx(context.Background(), owner, isForUpdate)
}

// OrganizationByIDCtx retrieves a row from 'public.organizations' as a Organization.
//
// Generated from index 'organizations_pkey'.
func (q OrganizationQ) OrganizationByIDCtx(ctx context.Context, id uuid.UUID, isForUpdate bool) (*data.Organization, error) {
	// query
	sqlstr := `SELECT ` +
		`id, did, owner, domain, metadata, status, verification_code, issued_claims_count, members_count, created_at, updated_at, type, schema_url ` +
		`FROM public.organizations ` +
		`WHERE id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.Organization
	err := q.db.GetRawContext(ctx, &res, sqlstr, id)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// OrganizationByID retrieves a row from 'public.organizations' as a Organization.
//
// Generated from index 'organizations_pkey'.
func (q OrganizationQ) OrganizationByID(id uuid.UUID, isForUpdate bool) (*data.Organization, error) {
	return q.OrganizationByIDCtx(context.Background(), id, isForUpdate)
}

// RequestsByGroupIDCtx retrieves a row from 'public.requests' as a Request.
//
// Generated from index 'requests_group_index'.
func (q RequestQ) RequestsByGroupIDCtx(ctx context.Context, groupID uuid.UUID, isForUpdate bool) ([]data.Request, error) {
	// query
	sqlstr := `SELECT ` +
		`id, org_id, group_id, user_did, metadata, status, created_at, updated_at ` +
		`FROM public.requests ` +
		`WHERE group_id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res []data.Request
	err := q.db.SelectRawContext(ctx, &res, sqlstr, groupID)
	if err != nil {
		return nil, errors.Wrap(err, "failed to exec select")
	}

	return res, nil
}

// RequestsByGroupID retrieves a row from 'public.requests' as a Request.
//
// Generated from index 'requests_group_index'.
func (q RequestQ) RequestsByGroupID(groupID uuid.UUID, isForUpdate bool) ([]data.Request, error) {
	return q.RequestsByGroupIDCtx(context.Background(), groupID, isForUpdate)
}

// RequestsByOrgIDCtx retrieves a row from 'public.requests' as a Request.
//
// Generated from index 'requests_organization_index'.
func (q RequestQ) RequestsByOrgIDCtx(ctx context.Context, orgID uuid.UUID, isForUpdate bool) ([]data.Request, error) {
	// query
	sqlstr := `SELECT ` +
		`id, org_id, group_id, user_did, metadata, status, created_at, updated_at ` +
		`FROM public.requests ` +
		`WHERE org_id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res []data.Request
	err := q.db.SelectRawContext(ctx, &res, sqlstr, orgID)
	if err != nil {
		return nil, errors.Wrap(err, "failed to exec select")
	}

	return res, nil
}

// RequestsByOrgID retrieves a row from 'public.requests' as a Request.
//
// Generated from index 'requests_organization_index'.
func (q RequestQ) RequestsByOrgID(orgID uuid.UUID, isForUpdate bool) ([]data.Request, error) {
	return q.RequestsByOrgIDCtx(context.Background(), orgID, isForUpdate)
}

// RequestByIDCtx retrieves a row from 'public.requests' as a Request.
//
// Generated from index 'requests_pkey'.
func (q RequestQ) RequestByIDCtx(ctx context.Context, id uuid.UUID, isForUpdate bool) (*data.Request, error) {
	// query
	sqlstr := `SELECT ` +
		`id, org_id, group_id, user_did, metadata, status, created_at, updated_at ` +
		`FROM public.requests ` +
		`WHERE id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.Request
	err := q.db.GetRawContext(ctx, &res, sqlstr, id)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// RequestByID retrieves a row from 'public.requests' as a Request.
//
// Generated from index 'requests_pkey'.
func (q RequestQ) RequestByID(id uuid.UUID, isForUpdate bool) (*data.Request, error) {
	return q.RequestByIDCtx(context.Background(), id, isForUpdate)
}

// RequestsByUserDidCtx retrieves a row from 'public.requests' as a Request.
//
// Generated from index 'requests_user_index'.
func (q RequestQ) RequestsByUserDidCtx(ctx context.Context, userDid sql.NullString, isForUpdate bool) ([]data.Request, error) {
	// query
	sqlstr := `SELECT ` +
		`id, org_id, group_id, user_did, metadata, status, created_at, updated_at ` +
		`FROM public.requests ` +
		`WHERE user_did = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res []data.Request
	err := q.db.SelectRawContext(ctx, &res, sqlstr, userDid)
	if err != nil {
		return nil, errors.Wrap(err, "failed to exec select")
	}

	return res, nil
}

// RequestsByUserDid retrieves a row from 'public.requests' as a Request.
//
// Generated from index 'requests_user_index'.
func (q RequestQ) RequestsByUserDid(userDid sql.NullString, isForUpdate bool) ([]data.Request, error) {
	return q.RequestsByUserDidCtx(context.Background(), userDid, isForUpdate)
}

// UsersByDidCtx retrieves a row from 'public.users' as a User.
//
// Generated from index 'users_did_index'.
func (q UserQ) UsersByDidCtx(ctx context.Context, did string, isForUpdate bool) ([]data.User, error) {
	// query
	sqlstr := `SELECT ` +
		`id, did, org_id, role, created_at, updated_at ` +
		`FROM public.users ` +
		`WHERE did = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res []data.User
	err := q.db.SelectRawContext(ctx, &res, sqlstr, did)
	if err != nil {
		return nil, errors.Wrap(err, "failed to exec select")
	}

	return res, nil
}

// UsersByDid retrieves a row from 'public.users' as a User.
//
// Generated from index 'users_did_index'.
func (q UserQ) UsersByDid(did string, isForUpdate bool) ([]data.User, error) {
	return q.UsersByDidCtx(context.Background(), did, isForUpdate)
}

// UserByIDCtx retrieves a row from 'public.users' as a User.
//
// Generated from index 'users_pkey'.
func (q UserQ) UserByIDCtx(ctx context.Context, id uuid.UUID, isForUpdate bool) (*data.User, error) {
	// query
	sqlstr := `SELECT ` +
		`id, did, org_id, role, created_at, updated_at ` +
		`FROM public.users ` +
		`WHERE id = $1`
	// run
	if isForUpdate {
		sqlstr += " for update"
	}
	var res data.User
	err := q.db.GetRawContext(ctx, &res, sqlstr, id)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, nil
		}

		return nil, errors.Wrap(err, "failed to exec select")
	}

	return &res, nil
}

// UserByID retrieves a row from 'public.users' as a User.
//
// Generated from index 'users_pkey'.
func (q UserQ) UserByID(id uuid.UUID, isForUpdate bool) (*data.User, error) {
	return q.UserByIDCtx(context.Background(), id, isForUpdate)
}
